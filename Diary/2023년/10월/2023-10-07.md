---
title : JPA N+1 문제
keyword : Lazy, Eager, FetchJoin, EntityGraph, BatchSize
--- 

- N+1 문제는 개발자가 직접 쿼리를 작성하지 않는 ORM 환경에서 일어날 수 있는 문제로, 연관 관계가 설정된 엔티티를 조회하는 과정에서 하나의 쿼리로 처리가 가능한 것을 조회된 데이터의 개수인 N번의 쿼리가 추가로 발생함에 따라 성능 저하를 일으키는 문제입니다.
- 원인은 JPA가 JPQL을 분석해서 쿼리를 생성하는 동작 방식 때문입니다. Team과 Member가 OneToMany의 연관 관계로 되어있고 팀에 따른 멤버들을 조회하고자 할 때, 개발자라면 SELECT * FROM TEAM JOIN MEMBER 로 멤버 테이블을 조인해서 팀을 불러옴으로써 한 번의 쿼리만을 날릴 것입니다.
- 그러나 JPA는 오로지 JPQL만을 분석하게 되고 처음 날리는 쿼리는 TEAM에 대한 findAll 이므로 SELECT * FROM TEAM 만 나가게 됩니다.
- 이미 결과를 가져왔으므로 JOIN은 불가능하고 각 팀의 멤버를 일일이 SELECT 해서 가져오므로 N번의 쿼리가 추가로 발생하게 되는 것입니다.
- 우선 JPA는 JPQL을 분석할 때 글로벌 Fetch 전략을 고려하지 않으므로 Fetch전략이 eager인지 lazy인지는 중요하지 않습니다. 언제 N+1 문제가 발생하느냐의 차이이지 해결방법이 될 수는 없습니다.
- 이에 대한 해결방법으로는 JPQL을 직접 작성하여 연관된 엔티티를 한꺼번에 모두 조회하는 fetch join을 이용하는 방법, @EntityGraph 어노테이션을 이용하는 방법, 그리고 @BatchSize 어노테이션이나 설정을 통해 쿼리를 사이즈만큼 모아두었다가 한꺼번에 한 번의 쿼리로 요청하도록 하는 방법이 있습니다.