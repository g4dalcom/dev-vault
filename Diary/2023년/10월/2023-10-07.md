---
title : JPA N+1 문제
keyword : Lazy, Eager, FetchJoin, EntityGraph, BatchSize
--- 

- N+1 문제는 개발자가 직접 쿼리를 작성하지 않는 ORM 환경에서 일어날 수 있는 문제로, 연관 관계가 설정된 엔티티를 조회하는 과정에서 하나의 쿼리로 처리가 가능한 것을 조회된 데이터의 개수인 N번의 쿼리가 추가로 발생함에 따라 성능 저하를 일으키는 문제입니다.
- 원인은 JPA가 JPQL을 분석해서 쿼리를 생성하는 동작 방식 때문입니다. JPA는 메소드 이름을 분석해서 엔티티 객체와 필드 이름을 가지고 쿼리를 생성하는데, 
- 만약 하나의 팀에 여러 명의 소속된 멤버가 있다고 할 때 개발자가 직접 SQL을 짠다면, SELECT * FROM team JOIN member 를 통해 한 번의 쿼리로 모든 데이터를 불러오겠지만
- JPA는 Team 엔티티의 findAll() 메소드를 실행해서 SELECT * FROM team 이라는 쿼리만 생성해서 팀을 불러오게 되고 fetch 전략에 따라 불러오는 시점은 다르지만 이후에 일일이 해당 팀에 대한 멤버를 SELECT 해서 불러오게 되는 것입니다.
- 이에 대한 해결 방법으로는 연관된 엔티티를 모두 함께 불러와서 영속화하는 fetch join을 이용하는 방법과 @EntityGraph 어노테이션을 사용하는 방법, 또한 BatchSize를 설정해둠으로써 쿼리를 배치 사이즈만큼 모았다가 쿼리하도록 함으로써 쿼리의 개수를 어느정도 조절할 수가 있습니다. 
- JPA는 만능이 아니기 때문에 Querydsl과 같은 플러그인을 이용하는 것도 좋은 방법입니다.