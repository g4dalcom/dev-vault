- CORS
	- 교차출처리소스공유정책
	- 보안상 프로토콜(http), 도메인, 포트가 동일한 요청만 수락하고 그 외에는 서버의 허락이 필요
	- 클라이언트의 Origin과 서버의 ACCESS-CONTROL-ALLOW-ORIGIN을 비교
	- get, post, head 요청인 simple request를 제외한 모든 요청은 preflight 요청을 거침(OPTION메소드)
- OSI 7 계층
- TCP/UDP
	- 모두 패킷 전송을 위한 프로토콜의 일종
	- TCP는 3, 4way-handshaking을 통해 연결과 해제 과정을 거치고 신뢰성 있는 패킷을 전송하는 프로토콜로 파일 전송과 같은 경우에 사용
	- UDP는 연결 과정 없이 일방적으로 순서없이 패킷을 전송하는 비연결형 데이터그램방식으로 1:N 통신이 가능하고 연속성이 중요한 스트리밍 서비스 같은 것에 사용
- SSL/TLS
	- HTTP는 웹에서 데이터를 주고받기 위한 통신 규약으로 서버가 클라이언트의 상태를 보존하지 않는 무상태성과 요청에 대한 응답 이후 연결을 유지하지 않는 비연결성의 특징을 갖는다.
	- 기존 HTTP가 전송계층의 TCP에서 동작한다면, HTTPS는 SSL이라는 보안소켓계층 위에서 데이터를 암호화하여 보안이 보장된 통신을 하는 프로토콜이며 검색엔진 최적화(SEO)에서도 HTTPS가 유리하다.
	- 따라서 SSL은 클라이언트와 서버가 서로 데이터를 암호화해서 통신할 수 있도록 돕는 보안 계층이며 요즘에는 TLS라는 좀 더 보안이 강화된 이름으로 불림
- DNS
	- 인터넷 주소 IP는 숫자로 되어 있는데 사람이 외우거나 사용하기 어렵기 때문에 비교적 쉬운 문자열로 바꾸어서 쉽게 서비스에 접근할 수 있도록 도와주는 인터넷 주소 전화번호부라고 할 수 있다.
- 데드락(https://gyoogle.dev/blog/computer-science/operating-system/DeadLock.html)
	- 멀티스레드나 멀티프로세스 환경에서 하나의 프로세스가 다른 프로세스를 기다리고 다른 프로세스 또한 반대 프로세스를 기다림으로써 영원히 교착상태에 빠지는 현상
	- 상호배제(자원은 한 번에 한 프로세스만 사용 가능)
	- 점유 대기(최소한 하나의 자원을 점유하면서 다른 추가 자원을 사용하기 위해 대기하는 프로세스가 존재)
	- 비선점(다른 프로세스가 점유중인 자원은 프로세스 종료 전까지 빼앗아 올 수 없음)
	- 순환 대기(프로세스가 순환 형태로 대기)
- 일급객체/일급함수
	- 일급 객체란 객체를 변수에 담거나 파라미터로 전달하거나 반환값으로 사용할 수 있는 것을 의미
	- 일급 함수란 함수를 일급 객체로 취급하는 것으로 이로인해 콜백함수, 고차함수, 클로저가 가능해진다.
	- 고차함수란 함수를 파라미터로 받거나 반환값으로 사용할 수 있는 함수
	- 콜백함수는 함수를 동기적으로 실행할 때 주로 사용하는데 함수를 매개변수로 넘기는 것
- MSA
	- 하나의 어플리케이션을 여러개의 작은 어플리케이션으로 쪼개서 조합한 형태
	- 서비스 중 장애가 난 부분이 전체에 영향을 덜 미침, 서비스를 부분적으로 변경하기 유리함, 빌드나 테스트의 시간이 줄어듦
- SQL/NOSQL
	- SQL은 정해진 스키마에 따라 테이블에 저장을 하고 중복을 피하기 위해 테이블 정규화를 함
	- NOSQL은 정해진 스키마가 없어서 유연하고 서버의 확장이 자유로움
	- SQL은 은행시스템과 같이 데이터가 자주 변경되거나 데이터의 무결성이 중요한 경우,
	- NOSQL은 SNS시스템과 같이 주로 데이터 읽기를 하고 로그나 이력과 같은 단순 기록형, 초당 동시 처리가 중요한 경우에 이용됨
- node.js 이벤트루프
	- 자바스크립트 코드를 실행시키면 자바스크립트 엔진은 콜스택에 전역 실행 컨택스트를 푸시합니다. 이후 함수가 호출될 때마다 콜스택에 실행 컨택스트가 생성되어 쌓이는 구조가 되고 가장 위에 놓인 실행 컨택스트만 활성화 상태가 됩니다.
	- 실행 컨택스트에는 함수에서 사용되는 지역변수나 매개변수 등, 그리고 스코프 체이닝을 위한 상위 컨택스트 정보와 같은 것들이 기록되고 함수가 종료되면 실행 컨택스트는 콜스택에서 pop되어 사라지게 됩니다.
	- 순차적으로 콜스택의 실행 컨택스트를 실행하는 과정에서 바로 처리할 수 없는 함수는 이벤트큐라는 공간에 담아두게 되고 콜스택이 모두 비게되면 이벤트큐의 요소를 하나씩 콜스택으로 보내서 처리하는 과정을 거칩니다.
- 원시/참조타입
	- string, number, boolean, null, undefined와 같은 값을 원시값이라고 하고 이 원시자료형들은 변수에 담게되면 값 자체가 담기게 됩니다. 또한 이 변수를 다른 변수에 할당하면 원시값 자체가 복사되며 변경이 불가능한 읽기전용 값입니다.
	- 객체나 배열과 같은 참조 타입은 변수에 할당하면 변수를 가리키고 있는 주솟값이 담기게 되고 이 변수를 다른 변수에 할당하면 주솟값을 복사합니다. 따라서 하나의 변수에서 값을 변경하면 다른 변수 또한 영향을 받게 됩니다.
	- 참조 타입을 복사하는 방법으로는 slice()나 Object.asign, 스프레드 문법 등이 있는데 참조 자료형 내부에 중첩된 참조 자료형은 얕은 복사가 일어나기 때문에 같은 주솟값을 공유합니다.
	- 깊은 복사를 위해서는 JSON.stringify() 메소드로 객체를 문자열 형태로 변환하여 원본 객체와 참조를 끊고 JSON.parse() 메소드로 다시 객체화하는 방법이 있는데 이 경우에도 중첩된 참조 자료형 중 함수가 있는 경우 함수가 null로 바뀌게 됩니다.
	- 따라서 보통은 lodash와 같은 라이브러리를 많이 사용합니다.
- 스코프
	- 변수나 함수에 접근할 수 있는 범위
	- 스코프체이닝에 의해 하위 스코프는 상위 스코프에 있는 변수에 접근이 가능합니다.
- 프로미스
	- 비동기 환경에서 함수를 순차적으로 실행해야 할 필요성이 있을 때 사용되는, 비동기 작업의 결과를 담고 있는 객체입니다.
	- 비동기 작업이 끝난 후에 필요할 때 결과를 받아서 다른 연관된 작업을 처리할 수 있고 프로미스 객체를 함수로 만들어서 반복되는 비동기 작업에 사용함으로써 재사용성을 높일 수도 있습니다.
- CSR/SSR
	- CSR은 처음에 서버로부터 빈 HTML과 모든 로직이 담긴 Javascript를 받아오고 클라이언트단에서 DOM을 동적으로 그려내는 방식입니다. 자바스크립트를 이용해 동적으로 돔을 그려내므로 필요한 부분만 업데이트할 수 있어서 SPA에 적합한 방식입니다. 처음에 서버로부터 모든 자바스크립트를 받아오기 때문에 첫 진입 때 로딩 속도가 느립니다.
	- SSR은 서버에서 완성된 HTML을 내려주는 방식입니다. 따라서 페이지마다 HTML이 따로 존재하고 해당 페이지의 로직만을 불러오기 때문에 초기 로딩 속도는 CSR에 비해 빠릅니다. 페이지 이동시마다 새로운 HTML을 받아오기 때문에 화면 깜빡임 현상이 있고 매번 처음처럼 HTML을 받아오기 때문에 페이지 이동은 CSR에 비해 느릴 수 있습니다.
	- SEO 관점에서는 각각의 페이지마다 메타데이터를 구분할 수 있는 SSR이 유리하다.
- FLUX패턴
	- MVC 패턴의 경우 모델과 뷰가 상호작용하는 과정에서 서로를 변경할 수가 있는데 대규모 어플리케이션에서 이러한 양방향 데이터 흐름은 유지보수를 어렵게 하였습니다. 
	- 그래서 데이터의 흐름은 단방향으로 일관적으로 가져감으로써 프로그램의 예측 가능성을 높이는 패턴입니다.
	- 사용자의 입력을 기반으로 Action을 만들고 이 Action을 Dispatcher에 전달하여 Store의 데이터를 변경한 후 View에 반영하는 단방향 흐름을 갖습니다.
	- 상태는 Store에서 관리를 하고 상태의 변경은 Action에 의해서만 가능하도록 하는 것
- 바벨
	- 바벨은 자바스크립트 트랜스파일러입니다.
	- 개발자가 작성한 코드를 기계어로 변환하는 작업을 컴파일이라고 한다면, 트랜스파일은 같은 언어를 다른 실행 환경에서도 돌아갈 수 있도록 바꾸어주는 것입니다.
	- 브라우저가 ES6 문법을 지원하지 않을 때 해당 코드를 ES6 이전 코드로 바꾸어준다거나 tsx나 jsx 파일을 js파일로 바꾸어주어서 브라우저가 읽을 수 있도록 하는 역할을 합니다.
- 디바운스, 쓰로틀링
	- 디바운스와 쓰로틀링은 연속적으로 호출되는 이벤트의 실행빈도를 제어함으로써 성능 최적화를 하기 위한 기술입니다.
	- 디바운스는 일정시간 안에 여러번의 이벤트 호출이 있게 되면 이벤트를 발생시키지 않다가 특정 시간이 지날 때까지 이벤트가 발생하지 않으면 그때서야 한 번의 이벤트만 발생시키는 것입니다.
	- 게시글 등록 버튼을 여러번 눌렀을 때 같은 게시글이 클릭수만큼 등록되지 않고 단 한 번만 등록되게 하는 데 사용될 수 있습니다.
	- 구현방법으로는 timer를 설정해두고 timer가 지나기 전에 이벤트 호출이 되면 timer를 초기화하고 timer가 지났을 때만 이벤트를 발생시킵니다.
	- 쓰로틀링은 이벤트를 일정 주기마다 발생시키는 것입니다.
	- 쓰로틀링 또한 timer를 설정해두는데 timer가 지나기 전에 이벤트 호출이 있을 때 timer를 초기화하지 않고 이벤트만 발생시키지 않습니다. timer를 1초라고 한다면 1초에 한 번씩 이벤트를 발생시키는 것입니다.
	- 쓰로틀링은 자동완성 기능처럼 어느정도 이벤트 빈도를 조절하면서 기능이 계속적으로 동작하고 있다는 느낌을 받게 할 수 있습니다.
- 렉시컬스코프
	- 함수가 어디서 호출되었는지가 아니라 어디서 선언되었는지에 따라 상위 스코프가 결정되는 정적 스코프를 의미합니다.
	- 예를 들어서 x라는 전역 변수가 있고, a라는 함수가 x라는 변수를 가지고 있으며 a함수 내부에서 b함수를 호출했을 때 b함수가 접근하는 변수 x는 호출한 a함수의 x가 아니라 전역변수가 된다는 것입니다.
- 클로저
	- 어떠한 함수가 내부 함수를 가지고 있고 내부 함수가 외부 함수의 변수를 참조하고 있을 때, 외부함수가 종료되어 콜스택에서 제거되었다고 해도 내부 함수에서 외부 함수의 변수에 접근할 수 있는데 이러한 함수를 클로저라고 합니다.
	- 실행 컨택스트의 관점에서 외부함수가 내부 함수를 반환하면서 종료되고 콜스택에서 제거가 됩니다. 그러면 외부 함수의 변수 또한 사라지게 되는데, 반환된 내부 함수를 호출했을 때 외부 함수의 변수에 접근할 수 있다는 것은 내부 함수가 선언되었을 때 자신의 상위 스코프인 외부 함수의 변수들을 기억하고 있다는 뜻입니다.
	- 이러한 클로저는 어떠한 변수를 특정 함수를 이용해서만 관리하고 싶을 때처럼 캡슐화와 은닉화를 하는 데에 사용될 수 있습니다.
- 커링
	- 여러 전달인자를 가진 함수를 연속적으로 함수를 리턴하는 방식으로 변경하는 것을 의미합니다.
	- 예를 들어서 a와 b라는 매개변수를 받아서 a+b를 리턴하는 함수가 있다고 할 때 a라는 매개변수를 받는 함수가 두 번째 함수를 리턴하고 두 번째 함수는 b라는 매개변수를 받아서 a+b를 리턴하는 방식입니다. 매개변수를 모두 받아서 리턴하는 것과의 차이는 함수의 일부만 호출하거나 일부 프로세스만 완료된 상태를 저장할 수 있다는 데에 차이가 있습니다.