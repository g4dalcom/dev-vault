---
title : inner join 과 outer join
keyword : 교집합, 합집합
--- 

- inner join은 교집합입니다. A와 B테이블을 inner join하면 A와 B에 둘 다 존재하는 데이터만 검색이 됩니다.
- outer join은 left outer join, right outer join, full outer join으로 나눌 수 있는데 left, right 의 경우는 특정 테이블을 기준으로 해당 테이블의 모든 데이터와 또 다른 테이블의 중복 데이터를 검색하는 것이고 full outer join은 두 테이블의 합집합, 그러니까 모든 데이터들을 가져오면서 빈 컬럼은 null로 채우게 됩니다.

- 디스패처 서블릿
	- 디스패처 서블릿은 클라이언트의 요청을 최초로 받는 프론트 컨트롤러입니다. 
	- 저는 디스패처 서블릿이 개발에 있어서 PM의 역할을 한다고 이해를 하고 있습니다. 클라이언트의 요청을 받아서 적절한 개발자에게 해당 이슈를 할당하고 처리된 데이터들을 취합해서 최종적으로 완성된 프로덕트를 반환하는 역할을 하게 됩니다.
	- 우선 요청을 받으면 해당 요청을 처리할 컨트롤러를 찾아서 할당을 하고, 할당 받은 컨트롤러는 비즈니스 로직을 처리합니다. 또한 사용자에게 보여줄 적절한 View를 view resolver가 찾으면 비즈니스로직과 view의 정보가 담긴 ModelAndView 객체를 이용해 View 를 만들게 되고 최종적으로 클라이언트에게 응답해주는 역할을 합니다.
- JPA
	- JPA는 자바 언어를 데이터베이스가 알아들을 수 있도록 해주는 번역기와 같습니다. 원래 데이터베이스에 접근을 할 때는 SQL이라는 쿼리 언어를 이용해야 하는데 개발자가 직접 SQL을 모두 작성하게 되면 비즈니스 로직에 집중하기 어려워지기 때문에 이러한 점을 개선하고자 나온 기술이 ORM이고 자바 진영에서 사용하는 ORM 기술 표준이 JPA입니다. 
	- JPA를 사용하면 개발자가 직접 SQL을 작성하지 않아도 JPA가 매핑된 클래스와 필드 정보를 통해 메소드 이름을 기반으로 쿼리를 생성하게 되므로 생산성이 크게 향상될 수 있고 데이터베이스마다 조금씩 다른 언어를 설정 파일을 조금 건드려주는 것만으로도 커버할 수 있기 때문에 유지보수성도 높아집니다.
	- 다만 개발자가 직접 쿼리를 작성하는 것이 아닌 만큼 의도하지 않은 N+1 문제나 성능 저하가 있을 수 있기 때문에 복잡한 쿼리는 직접 JPQL을 작성하거나 querydsl과 같은 qeury builder 라이브러리를 사용하기도 합니다.
- Spring Bean
	- 스프링 빈은 생명주기를 개발자가 아니라 스프링 IoC컨테이너가 담당하는 객체입니다. 객체의 관리를 개발자가 신경쓰지 않고 비즈니스 로직에 집중할 수 있다는 장점이 있습니다.
	- 빈으로 등록하는 방법은, @Component 어노테이션을 붙이면 최초 스프링이 시작될 때 컴포넌트 스캔을 통해 모든 컴포넌트 어노테이션이 붙은 클래스를 스프링이 빈으로 등록하게 됩니다. 또한 @Configuration 어노테이션 안에 @Bean 어노테이션을 붙인 메소드를 만들면 해당 메소드가 빈으로 등록이 됩니다.
- filter, interceptor
	- 로깅이나 예외 처리와 같은 수많은 메소드에 공통적으로 적용이 되는 기능들이 있는데 이러한 기능들을 매번 작성하면 중복 코드가 많아지고 유지보수도 어려워집니다.
	- 이러한 공통 로직을 처리할 때 사용하는 것이 필터와 인터셉터입니다.
	- 필터는 스프링과 무관하게 디스패처 서블릿에게 요청이 전달되기 전후로 동작을 하기 때문에 톰캣과 같은 웹 컨테이너에 의해 제어가 되고 인터셉터는 컨트롤러에 요청이 전달되기 전후로 스프링 컨테이너에 의해 제어가 된다는 데서 차이가 있습니다.
	- 때문에 필터는 특정 요청이나 컨트롤러와 관계없이 어플리케이션 전역에서 사용되는 공통 로직을 처리할 때 사용하고 인터셉터는 클라이언트 요청에 대해 추가적인 처리가 필요할 때 사용합니다.
- DI
	- DI는 어떠한 객체를 사용할 때 new 키워드를 통해 직접 생성하는 것이 아니라 외부에서 주입받음으로써 객체간의 관계를 느슨하게 하는 기술입니다.
	- 객체 사이에 인터페이스를 두면 해당 인터페이스를 구현하고 있는 여러 클래스들 중 필요한 클래스를 런타임시에 동적으로 주입받을 수 있기 때문에 객체간 관계가 느슨해지고 코드 재사용성과 유지보수성을 높일 수가 있습니다.
	- 의존성을 주입하는 방법으로는 필드 선언을 통한 필드주입, Setter를 통한 수정자 주입도 있지만 final 선언이 가능해서 불변성이 보장된다는 점과 필수적으로 사용해야 하는 요소 없이는 인스턴스를 만들지 못하도록 강제할 수 있다는 점 때문에 생성자 주입이 많이 사용됩니다.