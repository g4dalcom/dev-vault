---
title : 운영체제(OS)
keyword : 어노테이션, 스프링 실행순서, MVC패턴, PCB, 스택, 큐, 이진탐색, 동기와 비동기, 프로세스 동기화(스핀락, 뮤텍스, 세마포어), 디자인패턴, 가상메모리, cpu스케줄링
--- 

###### 어노테이션

- 어노테이션은 주석처럼 클래스나 메소드가 어떤 기능을 담당하는지를 나타내는 메타 데이터이기도 하고 빌드시에 어떠한 코드를 자동으로 생성하거나 기능을 수행하도록 해서 반복적인 코드량을 줄이고 가독성을 향상시켜서 개발생산성과 유지보수성을 높이는 자바의 주요 기능입니다.

###### 스프링 실행 순서

- 톰캣이 실행되면서 web.xml 파일을 읽어서 초기 설정작업을 하게 되고 context.xml 의 설정에 따라 스프링 컨테이너가 구동됩니다. 이후에 리퀘스트 요청이 오면 디스패처서블릿이 생성되며 아래의 순서를 따르게 됩니다.
- 클라이언트가 처리할 정보를 서버에 요청함
- 들어온 요청에 해당하는 컨트롤러가 있는지 확인 후 컨트롤러에게 처리 요청
- 컨트롤러에서 처리한 결과를 보여주기 위해 view로 리턴
-  컨트롤러에서 리턴한 view에 해당하는 이름을 찾은 후 view 에 처리 요청
- 처리 결과가 포함된 view를 클라이언트에 전송

###### MVC 패턴

- MVC 패턴은 인터페이스와 비즈니스 로직을 분리해서 유지보수성과 협업을 용이하게 하고자 하는 데 목적이 있는 패턴입니다.
- 데이터 처리를 담당하는 model과 화면인 view 그리고 클라이언트와 요청을 주고 받는 controller 세 영역이 상호작용 하며 클라이언트와 비즈니스 로직 중 어느 한쪽이 변경되어도 다른 쪽은 영향을 받지 않는다는 점이 특징입니다.


###### 스택, 큐

- 스택은 후입선출의 원리를 따르는 자료구조로 위가 뚫려있는 상자에 데이터를 차곡차곡 쌓는 듯한 구조입니다. 따라서 나중에 들어간 자료가 먼저 나오게 됩니다.
- 큐는 선입선출의 원리를 따르는 자료구조로 데이터가 들어오는 입구과 출구가 따로 있어서 먼저 들어온 데이터가 먼저 빠져나가는 구조입니다.

###### 이진탐색

- 이진 탐색은 정렬된 데이터 리스트를 탐색하는데 매번 탐색할 때마다 탐색 범위가 절반씩 줄어드는 알고리즘입니다.
- 정렬된 리스트에서 중간값을 선택하고 중간값보다 큰 지 작은 지에 따라 어느 한쪽만 탐색하면 되기 때문에 매번 탐색 범위가 절반씩 줄어들게 됩니다.

###### PCB (Process Control Block)

- 하나의 CPU는 하나의 프로세스만을 점유할 수가 있는데 여러 개의 프로세스를 동시에 실행시키는 것처럼 보이는 컨택스트 스위칭 과정에서 프로세스 식별자나 프로세스 진행 상태 등과 같은 정보들을 저장하고 있는 객체로 링크드리스트로 관리가 됩니다.
- 각 프로세스가 생성될 때 고유의 PCB가 생성이 되고 프로세스가 종료되면 PCB 또한 제거가 됩니다.

###### 동기와 비동기

- 어떠한 작업을 순차적으로 진행하는 것. 그러니까 어떠한 요청에 대한 응답이 있기 전까지 다른 후순위 작업들은 블록되는 상태를 동기라고 하고
- 앞선 작업과 상관없이 여러 작업이 동시에 처리될 수 있는 상태를 논블록. 비동기라고 합니다.

###### 프로세스 동기화

- 멀티스레드 환경에서는 스택 영역만 고유로 가지고 있고 나머지 코드, 데이터, 힙 영역은 공유 자원으로 사용을 합니다. 이 때 이 공유자원을 여러 스레드가 서로 원하는 경쟁상태가 나타날 수 있고 이러한 경쟁 상태가 나타날 수 있는 영역을 임계 영역이라고 합니다.
- 임계영역에서 교착 상태가 나타나지 않도록 하는 기술에는 스핀락, 뮤텍스, 세마포어가 대표적인데요,
- 스핀락은 임계 구역에 진입이 불가능할 때 진입이 가능할 때까지 루프를 돌면서 재시도하는 방식으로 구현된 락 방식입니다. 임계 구역에서의 작업이 길어지면 계속해서 재시도를 하며 자원을 낭비할 수 있습니다.
- 뮤텍스는 하나의 스레드가 임계 구역을 점유하고 있을 때 다른 스레드는 접근을 하지 못하도록 배제하는 기술입니다. 락이라고 하는 장치를 두고 임계영역에 들어가면서 뮤텍스 객체를 잠그고 임계 영역에서 작업을 수행한 스레드가 나오면서 락을 풀게 됨으로써 다음 스레드가 진입하게 되는 구조입니다. 스핀락과는 다르게 접근하지 못하는 스레드는 계속해서 재시도를 하는 게 아니라 락을 획득하지 못한 스레드들은 block 상태에 있다가 임계 영역에 있던 스레드가 나오면서 락을 풀면 block상태에 있던 스레드 중 하나가 다시 진입하게 되는 구조입니다.
- 세마포어는 공유 자원에 접근할 수 있는 스레드의 수를 조절하고 프로세스의 실행 순서를 다룰 수 있는 기술입니다. 세마포어는 양수인 초기값을 갖는데 이 초기값이 접근 가능한 스레드의 수를 나타냅니다. 초기값은 스레드가 사용할 때마다 감소시키고 반납할 때마다 증가시키며 양수를 유지하며 동기화하게 됩니다.
- 뮤텍스는 공유 자원을 오로지 하나의 스레드만 사용해야하는 상호배제 상황에서 사용할 수 있고 세마포어는 여러 스레드가 동시에 공유할 수 있는 경우에 사용할 수 있으며 교차적으로 사용될 수도 있습니다.


###### 디자인 패턴

- 팩토리 메소드 패턴
	- 클라이언트에서 직접 new 키워드를 통해 객체를 생성하는 것이 아니라 하나의 공장 클래스 혹은 인터페이스를 만들고 해당 클래스를 상속하는 서브 클래스에서 각각의 객체 생성을 책임지는 패턴입니다.
	- 객체간 결합도가 낮아지고 새로운 구현 클래스가 생겨도 기존 코드를 수정하는 것 없이 추가할 수 있다는 장점이 있습니다.
- 싱글톤 패턴
	- 객체의 인스턴스가 단 하나만 존재하도록 유지하는 패턴입니다. 기본적으로 생성자에 private 접근 제어자를 두어서 외부에서 객체의 인스턴스를 만들지 못하도록 하고 객체를 생성하는 메소드에 static을 붙여서 해당 메소드를 통해 객체 인스턴스를 생성하도록 합니다. 처음 호출되었을 때 객체 생성을 하고 그 이후에는 기존에 생성된 객체를 그대로 반환하는 식으로 구현이 됩니다.
	- 객체 생성 비용이 비싸거나 프로그램에서 공통으로 사용하는 옵션이나 세팅과 같은 기능의 객체에 주로 사용됩니다.
- 어댑터 패턴
	- 어떠한 인터페이스를 구현하고 있는 클래스가 있는데, 다른 내용을 정의하고 있는 인터페이스를 구현해야 할 때가 있습니다. 이 때 클래스 내용을 수정해서 추가적으로 다른 인터페이스를 구현하는 것이 아니라 구현하고 있는 인터페이스를 임플리먼트하는 어댑터 클래스를 만든 후 그 어댑터 클래스에서 다른 인터페이스를 불러오는 방식으로 클래스 수정 없이 호환되지 않는 인터페이스를 구현할 수 있게 해주는 패턴입니다.
	- 외부 API를 이용하는 경우 현재 구현된 어플리케이션과 호환되지 않는 경우가 있는데 그러한 경우에 어댑터 패턴을 사용해서 클래스 수정없이 적용시킬 수 있습니다.
	- 어댑터 패턴은 추가적인 코드 작성이 필요하고 클래스가 늘어나기 때문에 복잡성을 증가시키는 원인이 되며 어댑터 클래스를 통하는 과정에서 오버헤드가 발생할 수 있습니다.
- 전략 패턴
	- 여러가지 기능을 전략으로써 하나의 추상화된 상위 클래스 안에 미리 정의해두고 런타임시에 들어오는 input에 따라 해당 전략이 실행되도록 모듈화한 패턴입니다.
	- 어떤 일을 수행하는 동작이나 기능이 여러가지일 때 사용될 수 있고 기능이 추가될 때도 새롭게 정의만 하는 방식으로 확장할 수 있습니다.


###### 가상 메모리

- 프로세스가 실행되려면 주기억장치인 RAM에 프로세스가 올라와야 하는데 프로세스 전체를 올리는 것이 아니라 필요한 부분만 올리고 나머지는 상대적으로 용량이 크고 용량대비 값이 싼 보조 기억 장치(HDD)에 둠으로써 RAM의 효율을 높이는 기술입니다. 이로 인해서 메모리보다 더 큰 프로그램을 실행하거나 여러 프로그램을 메모리의 한계를 뛰어넘어서 실행시킬 수 있습니다.

###### CPU 스케쥴링

- CPU는 하나의 프로세스만 실행할 수 있습니다. 여러 프로세스가 컨택스트스위칭 되는 과정에서 어떤 프로세스가 CPU에 올라올 것인지를 결정하는 기술을 CPU 스케줄링이라고 합니다.
- 중요한 프로세스에 우선순위를 더 부여함으로써 더 빨리, 자주 실행되도록 조절하며 시스템 자원을 효율적으로 분배할 수 있도록 하는 기술입니다.