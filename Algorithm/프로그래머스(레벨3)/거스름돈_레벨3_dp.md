# [문제링크](https://school.programmers.co.kr/learn/courses/30/lessons/12907)

## 📝 문제

Finn은 편의점에서 야간 아르바이트를 하고 있습니다. 야간에 손님이 너무 없어 심심한 Finn은 손님들께 거스름돈을 n 원을 줄 때 방법의 경우의 수를 구하기로 하였습니다.

예를 들어서 손님께 5원을 거슬러 줘야 하고 1원, 2원, 5원이 있다면 다음과 같이 4가지 방법으로 5원을 거슬러 줄 수 있습니다.

- 1원을 5개 사용해서 거슬러 준다.
- 1원을 3개 사용하고, 2원을 1개 사용해서 거슬러 준다.
- 1원을 1개 사용하고, 2원을 2개 사용해서 거슬러 준다.
- 5원을 1개 사용해서 거슬러 준다.

거슬러 줘야 하는 금액 n과 Finn이 현재 보유하고 있는 돈의 종류 money가 매개변수로 주어질 때, Finn이 n 원을 거슬러 줄 방법의 수를 return 하도록 solution 함수를 완성해 주세요.

##### 제한 사항

- n은 100,000 이하의 자연수입니다.
- 화폐 단위는 100종류 이하입니다.
- 모든 화폐는 무한하게 있다고 가정합니다.
- 정답이 커질 수 있으니, 1,000,000,007로 나눈 나머지를 return 해주세요.

---

##### 입출력 예

|n|money|result|
|---|---|---|
|5|[1,2,5]|4|

---

### 💡 풀이

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fp9jPp%2FbtsAuwKBrsC%2FG7tMYOo1SMfhSTfGBFl65k%2Fimg.png)

- 1원은 1원 하나로 만들 수 있는 경우의 수를 저장하고 2원은 1원과 2원으로 만들 수 있는 경우의 수를 저장하는 것으로 표를 그려보았습니다.
- 우선 1원으로 0~6원을 만들 수 있는 방법의 수는 한 가지씩 밖에 존재하지 않죠?! (0원은 1가지 방법이 있다고 가정합니다.)
- 이것들을 우선 dp값에 저장해둡니다. dp\[3\] 은 3원을 만들 수 있는 경우의 수가 됩니다.
- 이제 1원과 2원으로 만들 수 있는 방법을 적어봅니다.
	- 1원은 1원 하나로만 만들 수 있으니 그대로 1개이고
	- 2원은 1원 2개, 2원 1개로 만들 수 있으니 경우의 수는 2개입니다.
	- 3원은 1원 3개, 1원 1개 + 2원 1개로 역시 2개입니다.
	- 4원은 1원 4개, 1원 2개 + 2원 1개, 2원 2개로 총 3개가 되네요.
- 여기서 1원으로 구할 수 있는 개수는 계속 중복되어서 계산이 되니까 dp값에 더해주어도 될 것 같습니다.
- 예를 들어서 1원 하나로 구하는 경우에서 dp\[4\] 가 1로 초기화 되었었다면, 1원+2원으로 구하는 경우에서는 dp\[4\] + @ 로 경우의 수가 늘어나는 것이죠!
- 그러면 @ 를 구하는 규칙만 찾으면 점화식을 세울 수 있을 것 같습니다.
- 기본적으로 dp\[x\] 는 동전의 수가 늘어나면 dp\[x\] + @ 가 됩니다. 1원 하나로 2원을 만드는 경우는 1가지 경우인데, 2원이 추가되면 1원으로만 만들수 있는 경우의 수 + 2원으로 만드는 경우의 수가 되니까 기존 dp값을 활용할 수가 있겠네요!
- 그리고 x원 동전이 추가될 때 x원보다 작은 금액에서는 아무런 영향을 못미치다가(3원으로 2원을 만드는 경우의 수는 존재하지 않으므로) 금액이 x가 되는 순간부터 x원의 경우의 수 1개가 추가됩니다.
- 그러면 3원 동전이 추가될 때 3원을 만드는 경우의 수는 dp\[3\] = dp\[3\] + dp\[0\] 이라고 볼 수 있는데요. 이를 확장하면 dp\[4\] = dp\[4\] + dp\[4 - 1\]이 되고 dp\[5\] = dp\[5\] + dp\[5 - 2\] . . .  라는 점화식이 완성됩니다.

### 🔍 정답

```java
class Solution {
    public int solution(int n, int[] money) {
        final int MOD = 1000000007;
        int[] dp = new int[n+1];
        dp[0] = 1;
        
        for (int i = 0; i < money.length; i++) {
            for (int j = money[i]; j <= n; j++) {
                dp[j] = dp[j] + dp[j - money[i]];
            }
        }
        
        return dp[n] % MOD;
    }
}
```