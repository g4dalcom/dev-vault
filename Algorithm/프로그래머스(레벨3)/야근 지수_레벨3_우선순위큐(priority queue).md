# [문제링크](https://school.programmers.co.kr/learn/courses/30/lessons/12927)

## 📝 문제

회사원 Demi는 가끔은 야근을 하는데요, 야근을 하면 야근 피로도가 쌓입니다. 야근 피로도는 야근을 시작한 시점에서 남은 일의 작업량을 제곱하여 더한 값입니다. Demi는 N시간 동안 야근 피로도를 최소화하도록 일할 겁니다.Demi가 1시간 동안 작업량 1만큼을 처리할 수 있다고 할 때, 퇴근까지 남은 N 시간과 각 일에 대한 작업량 works에 대해 야근 피로도를 최소화한 값을 리턴하는 함수 solution을 완성해주세요.

##### 제한 사항

- `works`는 길이 1 이상, 20,000 이하인 배열입니다.
- `works`의 원소는 50000 이하인 자연수입니다.
- `n`은 1,000,000 이하인 자연수입니다.

##### 입출력 예

|works|n|result|
|---|---|---|
|[4, 3, 3]|4|12|
|[2, 1, 2]|1|6|
|[1,1]|3|0|

##### 입출력 예 설명

입출력 예 #1  
n=4 일 때, 남은 일의 작업량이 [4, 3, 3] 이라면 야근 지수를 최소화하기 위해 4시간동안 일을 한 결과는 [2, 2, 2]입니다. 이 때 야근 지수는 22 + 22 + 22 = 12 입니다.

입출력 예 #2  
n=1일 때, 남은 일의 작업량이 [2,1,2]라면 야근 지수를 최소화하기 위해 1시간동안 일을 한 결과는 [1,1,2]입니다. 야근지수는 12 + 12 + 22 = 6입니다.

입출력 예 #3

남은 작업량이 없으므로 피로도는 0입니다.

---

### 💡 풀이

- 문제의 규칙을 찾으면 비교적 구현은 어렵지 않았습니다!
- 4 3 3이 최소 피로도가 되는 값은 2 2 2 인데 4 3 3에서 2 2 2가 어떻게 계산이 되는지를 따라가보았는데요.
- 처음에는 모든 요소들의 작업을 하나씩 균등하게 줄이고 나머지 작업이 있다면 가장 큰 피로도를 줄이면 되지 않을까라는 생각을 했었는데
- works = \[4, 3, 2, 1\] 이고 n = 4 라고 할 때, 작업량을 균등하게 줄인 3 2 1 0 보다 2 2 1 1 이 되는 경우가 최소값이라는 것을 알게되었습니다.
- 그러면 무작정 균등하게 값을 줄이는 것이 아니라 규칙이 따로 있겠다는 생각이 들었고 1이나 2와 같은 수는 줄였을 때 감소폭이 작지만 큰 수는 감소폭이 훨씬 크므로 그리디하게 생각해서 **배열에서 항상 가장 큰 값의 작업량**을 줄이면 되지 않을까 생각했습니다.
- 배열이 항상 내림차순으로 정렬되어야 하고, 확인해야 하는 값은 가장 큰 수이므로 우선순위큐가 적절한 것 같아서 아래와 같이 구현해보았습니다!

### 🔍 정답

```java
import java.util.*;

class Solution {
    public long solution(int n, int[] works) {
        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());

        for (int w : works) {
            pq.add(w);
        }

        while (n-- > 0) {
            if (pq.peek() <= 0) break;
            pq.add(pq.poll() - 1);
        }

        long sum = 0;
        while (!pq.isEmpty()) {
            sum += Math.pow(pq.poll(), 2);
        }

        return sum;
    }
}
```