# [문제링크](https://school.programmers.co.kr/learn/courses/30/lessons/68646)

## 📝 문제

일렬로 나열된 n개의 풍선이 있습니다. 모든 풍선에는 서로 다른 숫자가 써져 있습니다. 당신은 다음 과정을 반복하면서 풍선들을 단 1개만 남을 때까지 계속 터트리려고 합니다.

1. 임의의 **인접한** 두 풍선을 고른 뒤, 두 풍선 중 하나를 터트립니다.
2. 터진 풍선으로 인해 풍선들 사이에 빈 공간이 생겼다면, 빈 공간이 없도록 풍선들을 중앙으로 밀착시킵니다.

여기서 조건이 있습니다. 인접한 두 풍선 중에서 **번호가 더 작은 풍선**을 터트리는 행위는 최대 1번만 할 수 있습니다. 즉, 어떤 시점에서 인접한 두 풍선 중 번호가 더 작은 풍선을 터트렸다면, 그 이후에는 인접한 두 풍선을 고른 뒤 번호가 더 큰 풍선만을 터트릴 수 있습니다.

당신은 어떤 풍선이 최후까지 남을 수 있는지 알아보고 싶습니다. 위에 서술된 조건대로 풍선을 터트리다 보면, 어떤 풍선은 최후까지 남을 수도 있지만, 어떤 풍선은 무슨 수를 쓰더라도 마지막까지 남기는 것이 **불가능**할 수도 있습니다.

일렬로 나열된 풍선들의 번호가 담긴 배열 a가 주어집니다. 위에 서술된 규칙대로 풍선들을 1개만 남을 때까지 터트렸을 때 최후까지 남기는 것이 가능한 풍선들의 개수를 return 하도록 solution 함수를 완성해주세요.

---

##### 제한 사항

- a의 길이는 1 이상 1,000,000 이하입니다.
    - `a[i]`는 i+1 번째 풍선에 써진 숫자를 의미합니다.
    - a의 모든 수는 -1,000,000,000 이상 1,000,000,000 이하인 정수입니다.
    - a의 모든 수는 서로 다릅니다.

---

##### 입출력 예

|a|result|
|---|---|
|`[9,-1,-5]`|3|
|`[-16,27,65,-2,58,-92,-71,-68,-61,-33]`|6|

---

##### 입출력 예 설명

입출력 예 #1

- 첫 번째 풍선(9가 써진 풍선)을 최후까지 남기는 방법은 다음과 같습니다.
    1. `[9, -1, -5]` 에서 -1, -5가 써진 풍선을 고른 뒤, -1이 써진 풍선(번호가 더 큰 것)을 터트립니다.
    2. `[9, -5]` 에서 9, -5가 써진 풍선을 고른 뒤, -5가 써진 풍선(번호가 더 작은 것)을 터트립니다.
- 두 번째 풍선(-1이 써진 풍선)을 최후까지 남기는 방법은 다음과 같습니다.
    1. `[9, -1, -5]` 에서 9, -1이 써진 풍선을 고른 뒤, 9가 써진 풍선(번호가 더 큰 것)을 터트립니다.
    2. `[-1, -5]` 에서 -1, -5가 써진 풍선을 고른 뒤, -5가 써진 풍선(번호가 더 작은 것)을 터트립니다.
- 세 번째 풍선(-5가 써진 풍선)을 최후까지 남기는 방법은 다음과 같습니다.
    1. `[9, -1, -5]` 에서 9, -1이 써진 풍선을 고른 뒤, 9가 써진 풍선(번호가 더 큰 것)을 터트립니다.
    2. `[-1, -5]` 에서 -1, -5가 써진 풍선을 고른 뒤, -1이 써진 풍선(번호가 더 큰 것)을 터트립니다.
- 3개의 풍선이 최후까지 남을 수 있으므로, 3을 return 해야 합니다.

입출력 예 #2

- 최후까지 남을 수 있는 풍선은 -16, -92, -71, -68, -61, -33이 써진 풍선으로 모두 6개입니다.

---

### 💡 풀이

- 이 문제에서 가장 중요한 조건은 **인접한 두 풍선을 터뜨릴 때 기본적으로 더 큰 수의 풍선을 터뜨려야 하고 더 작은 수의 풍선을 터뜨릴 수 있는 횟수는 1회로 제한**이 된다는 것입니다.
- 그리고 인접한 풍선들은 배열에서 **현재 위치를 기준으로 왼쪽과 오른쪽**으로 나눌 수 있습니다. 어느 한쪽의 풍선을 터뜨렸다면 다른 풍선들을 현재 위치쪽에 밀착시켜야 하기 때문이죠! 그러므로 언제나 자신의 위치를 기준으로 왼쪽과 오른쪽 풍선만 비교하면 됩니다.

###### 아이디어 1

- 0번 인덱스와 마지막 인덱스는 인접한 풍선이 왼쪽 혹은 오른쪽 한쪽으로만 존재합니다.
- 0번 풍선을 기준으로 생각해보면, 0번 인덱스를 제외한 모든 풍선들을 큰 수를 우선으로 터뜨리면 가장 작은 수의 풍선이 하나 남을 것이고 그 풍선과 0번 풍선을 비교하면 0번 인덱스 풍선이 더 크든 작든 0번 풍선을 남길 수 있게 됩니다.
- 마지막 인덱스도 마찬가지겠죠?!
- 여기서 알 수 있는 사실은 0번과 마지막 풍선은 무조건 살릴 수 있다는 점입니다. 따라서 **a의 길이가 1이 아닌 이상 기본적으로 살릴 수 있는 풍선은 2개 이상**입니다.

###### 아이디어 2

- 만약 인접한 풍선을 터뜨릴 때 무조건 더 큰 수의 풍선만 터뜨릴 수 있다고 가정해볼까요?
- 이런 경우에는 최솟값인 풍선만이 마지막에 남는 풍선이 될 것입니다.
- 더 작은 수의 풍선을 터뜨릴 수 있는 기회가 한 번 주어진다는 것은 자신이 최솟값이 아니어도 된다는 의미이고 아이디어 1을 확장해서, **현재 위치에서 왼쪽의 모든 수들과 비교해서 최솟값이거나 오른쪽의 모든 수들과 비교해서 최솟값이라면 한 번의 특수 기회를 활용**해서 살릴 수 있게 됩니다.

###### 구현

- 위 아이디어들을 기반으로 a 배열을 순차적으로 탐색하며 현재 위치를 기준으로 left의 모든 수들과 right의 모든 수들과 비교해서 어떠한 한 방향에서 최솟값이 될 수 있는지 여부를 판단하도록 구현하였습니다.
- left의 경우는 순차적으로 탐색을 하며 최솟값을 갱신하는 방법으로 구현할 수 있지만 right의 경우는 매번 모든 right 값들과 비교하기에는 성능이 매우 떨어질 수 있기 때문에 미리 해당 위치에서의 최솟값을 저장해두었습니다.

```java
int[] min_right = new int[a.length];
min_right[a.length-1] = a[a.length-1];

for (int i = a.length-2; i > 0; i--) {
	min_right[i] = Math.min(min_right[i+1], a[i]);
}
```

- 만약 min_right[3] 이라면 최솟값과 a[3] 을 비교해서 더 작은 수가 입력이 되어있을 것이므로 순차 탐색을 할 때 a[i] == min_right[i] 라면 오른쪽에서는 최솟값이라는 의미겠죠?!

### 🔍 정답

```java
class Solution {
    public int solution(int[] a) {
        if (a.length == 1) return 1;
        
        int result = 2;
        int min_left = a[0];
        int[] min_right = new int[a.length];
        min_right[a.length-1] = a[a.length-1];
        
        for (int i = a.length-2; i > 0; i--) {
            min_right[i] = Math.min(min_right[i+1], a[i]);
        }
        
        for (int i = 1; i < a.length-1; i++) {
            if (a[i] < min_left || a[i] == min_right[i]) {
                result++;
            }
            min_left = Math.min(min_left, a[i]);
        }
        
        return result;
    }
}
```


### 💡 다른 정답

```java
import java.util.*;

class Solution {
    public int solution(int[] a) {
        int answer = 0;
        int min1 = Integer.MAX_VALUE;
        int min2 = Integer.MAX_VALUE;
        HashSet<Integer> hs = new HashSet<>();

        for(int i=0;i<a.length;i++){
            min1=Math.min(min1,a[i]);
            min2=Math.min(min2,a[a.length-1-i]);
            hs.add(min1);
            hs.add(min2);
        }
        return hs.size();
    }
}
```

- 다른 사람의 풀이는 단 한 번의 탐색으로 해결한 풀이입니다.
- 기본적인 접근법은 저의 풀이와 유사한데, hashset이 중복된 값을 저장하지 않는다는 점을 이용한 신박한 풀이입니다!