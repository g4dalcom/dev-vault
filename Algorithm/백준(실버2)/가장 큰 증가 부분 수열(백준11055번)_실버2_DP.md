# [문제링크](https://www.acmicpc.net/problem/11055)

## 📝 문제

수열 A가 주어졌을 때, 그 수열의 증가 부분 수열 중에서 합이 가장 큰 것을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {1, 100, 2, 50, 60, 3, 5, 6, 7, 8} 인 경우에 합이 가장 큰 증가 부분 수열은 A = {**1**, 100, **2**, **50**, **60**, 3, 5, 6, 7, 8} 이고, 합은 113이다.

## 입력

첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.

둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)

## 출력

첫째 줄에 수열 A의 합이 가장 큰 증가 부분 수열의 합을 출력한다.

## 예제 입력 1 
10
1 100 2 50 60 3 5 6 7 8

## 예제 출력 1 

113


---

### 🔍 정답

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class Main {

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());

        StringTokenizer st = new StringTokenizer(br.readLine());

        /**
         * 증가하는 수열(부분 수열)의 합 중 가장 큰 값을 구해야 하는 문제로, dp값은 부분 수열의 합을 저장할 것이다.
         * 입력값을 담을 arr배열과 부분 수열의 합을 담을 dp배열을 만들어준다.
         */
        int[] arr = new int[N + 1];
        int[] dp = new int[N + 1];

        /* 입력 받기 */
        for (int i = 1; i <= N; i++) {
            arr[i] = Integer.parseInt(st.nextToken());
        }

        /**
         * dp값을 각 arr값으로 초기값을 정해준다.
         * arr = [1 100 2 50 60 3 5 6 7 8]
         * dp = [1 100 2 50 60 3 5 6 7 8]
         * 1. 증가하는 수열이므로 이전 arr값과 비교해서 클 경우
         * 2. 가장 큰 값이어야 하므로 dp[i] 의 값을 계속 갱신해주면서 최댓값을 찾을 것이다. (아래 설명 참조!)
         */
        int max = 0;
        for (int i = 1; i <= N; i++) {
            dp[i] = arr[i];
            for (int j = 1; j <= i; j++) {
                if (arr[i] > arr[j] && dp[j] + arr[i] > dp[i]) {
                    dp[i] = dp[j] + arr[i];
                }
            }
            if (dp[i] > max) {
                max = dp[i];
            }
        }
        System.out.println(max);
    }
}
```

| IDX | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  |
|:--- |:--- |:--- |:--- |:--- |:--- |:--- |:--- | --- | --- | --- |
| arr | 1   | 100 | 2   | 50  | 60  | 3   | 5   | 6   | 7   | 8   |
| dp  | 1   | 100 | 2   | 50  | 60  | 3   | 5   | 6   | 7   | 8   | 
- DP값을 각 arr값으로 초기화한다.

| IDX | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  |
|:--- |:--- |:--- |:--- |:--- |:--- |:--- |:--- | --- | --- | --- |
| arr | 1   | 100 | 2   | 50  | 60  | 3   | 5   | 6   | 7   | 8   |
| dp  | 1   | 101 | 2   | 50  | 60  | 3   | 5   | 6   | 7   | 8   |
- dp[1] 은 비교 대상이 없으므로 dp[1] = 1
- dp[2] = 100 인데, 증가하는 수열이므로 (arr[1] < arr[2]), dp[2] = dp[1] + dp[2] = 101 이 된다.

| IDX | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  |
|:--- |:--- |:--- |:--- |:--- |:--- |:--- |:--- | --- | --- | --- |
| arr | 1   | 100 | 2   | 50  | 60  | 3   | 5   | 6   | 7   | 8   |
| dp  | 1   | 101 | 3   | 50  | 60  | 3   | 5   | 6   | 7   | 8   |
- dp[3] = 2 인데, arr[1] 과 먼저 비교해서 증가하는 수열이므로, dp[3] = dp[1] + dp[3] = 3 이 된다.
- 그리고 arr[2] 와 비교를 하는데, arr[2] < arr[3] 으로 증가하는 수열이라는 조건을 충족하지 못하므로 dp[3] = 3으로 탐색이 완료된다.

| IDX | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  |
|:--- |:--- |:--- |:--- |:--- |:--- |:--- |:--- | --- | --- | --- |
| arr | 1   | 100 | 2   | 50  | 60  | 3   | 5   | 6   | 7   | 8   |
| dp  | 1   | 101 | 3   | 53  | 60  | 3   | 5   | 6   | 7   | 8   |
- dp[4] = 50 인데, arr[1] 과 먼저 비교해서 증가하는 수열이므로, dp[4] = dp[1] + dp[4] = 51이 된다.
- 그리고 arr[2] 와 비교해서 증가하는 수열이 안 되므로 스킵,
- arr[3] 과 비교해서 증가하는 수열이므로 dp[4] = dp[3] + dp[4] = 53이 된다.
- 이 때, dp값은 최댓값을 저장해야 하므로 dp값이 더 작게 갱신되지 않도록 dp[i] < dp[j] + arr[i] 라는 조건을 넣은 것이다.
- 이대로 반복해서 가장 큰 값을 출력하면 완료!