# [문제링크](https://euler.synap.co.kr/quiz=9)

## 📝 문제

아래 코드영역에는 암호산술 문제가 한 줄에 하나씩 적혀있습니다.  

총 21줄, 624자의 코드

SYNAP + SOFT = WANTS + YOU
SEND +MORE = MONEY
EMAIL= SPAM + SPAM + SPAM + SPAM + SPAM + SPAM
FORTY +TEN+ TEN= SIXTY
NUMBER = SQUARE + SQUARE + SQUARE + SQUARE
SEVENTY = FIVE + SEVEN + ELEVEN + TWELVE + FIFTEEN + TWENTY
MANET + MATISSE + MIRO + MONET + RENOIR = ARTISTS
SIX+SIX+SIX = NINE + NINE
ABCDE\*F=GGGGGG
ADAM+AND+EVE=MOVED
FIVE+FIVE+NINE+ELEVEN=THIRTY
CROSS+ROADS=DANGER
USE + LESS = KIDDY
BILL + WILLIAM + MONICA = CLINTON
GREEN + ORANGE = COLORS
CEZANNE + MANET + MATISSE = ARTISTS
OLD+SALT+TOLD+TALL=TALES
COFFEE + COFFEE + COFFEE = THEOREM
SEND * ME = EMAIL
POWER = YOUR + SHOW
ALLEN = K * JEON

각 문제를 있는 그대로 읽어 들여 화면으로 답을 출력하는 프로그램을 작성하세요.  
가능한 모든 답의 좌변 숫자를 더한 값을 제출하세요.

---

### 💡 풀이

- 흐름은 대략 아래와 같습니다.
1. 입력값을 문자열과 연산자로 구분해서 List에 저장하기(순서대로 꺼내면서 계산하기 위해)
2. 문자열을 문자로 나누어서 중복을 제거하고 List에 저장하기(각 문자에 0~9까지를 할당하는 작업을 위해)
3. 각 문자열의 첫 문자에는 0이 들어갈 수 없으므로 해당 작업을 위해 첫 문자 List에 저장하기
4. 각 문자에 0~9까지의 숫자를 하나씩 집어넣습니다. [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1] ... 이런 식으로 순열을 이용합니다. 할당은 해시맵을 이용해서 key는 문자, value는 할당받은 수로 하였습니다. 종료 조건은 모든 문자에 수가 할당되었을 때(depth == alphabetSet.size()) 입니다.
5. 종료조건이 되면 계산 작업을 합니다. 문자열을 숫자로 바꿔서 numberQ에 넣고 연산자는 따로 operatorQ에 담았습니다. 그리고 '=' 을 만나면 numberQ와 operatorQ를 비우면서 leftSide에 저장해주었고, 그 이후의 숫자와 연산자도 동일하게 큐를 이용한 뒤 rightSide에 담아주고 둘을 비교하였습니다.

- 암호풀이라는 주제가 재밌어보였고 풀이한 사람이 많지 않아서 도전해보고 싶었습니다.
- 대충 흐름이 머릿속에 그려지기까지는 오래 걸리지 않았는데 막상 구현하면서 여러가지 시행착오를 겪었습니다.
- 저 같은 경우는 좌변과 우변을 한꺼번에 계산하고 비교하는 식인데
- 좌변과 우변의 각 일의 자리부터 계산하면서 맞지 않으면 다른 수를 할당하는 식으로 구현한다면 좀 더 탐색을 줄일 수 있지 않을까 싶은 생각이 들었습니다!

### 🔍 정답

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Queue;

public class Main {
    static HashMap<Character, Integer> map;
    static ArrayList<String> codeList;
    static ArrayList<Character> firstCharacter;
    static boolean[] visit;
    static int answer;      // 일치하는 연산의 좌변값들을 더한 결과값

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        while (true) {
            String readLine = br.readLine();
            if (readLine.equals("")) break;

            // 입력값의 공백을 제거하고 문자별로 나누어놓은 배열. ex) input = [S, Y, N, A, P, +, S, O, F, T, =, ... ]
            char[] input = readLine.replace(" ", "@").replace("@", "").toCharArray();

            map = new HashMap<>();                  // 문자와 그 문자의 할당된 수를 저장하는 해시맵. ex) {S=1, Y=4, N=3, ...}
            visit = new boolean[10];                // 순열 연산을 위한 방문 체크 배열(중복 순열 방지)

            /**
             * @codeList 단어와 연산자를 나누어놓은 리스트. ex) codeList = [SYNAP, +, SOFT, =, WANTS, +, YOU]
             * @alphabetSet 입력값의 문자 리스트(중복 제거). ex) alphabetSet = [S, Y, N, A, P, O, F, T, W, U]
             * 문자일 경우 연산자가 나오기 전까지 이어붙이고
             * 연산자일 경우 현재까지 이어붙인 문자열과 연산자 자신을 codeList에 push
             */
            codeList = new ArrayList<>();
            ArrayList<Character> alphabetSet = new ArrayList<>();
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i <= input.length; i++) {
                if (i == input.length) {
                    codeList.add(sb.toString());
                } else if (input[i] > 64) {
                    if (!alphabetSet.contains(input[i])) alphabetSet.add(input[i]);
                    sb.append(input[i]);
                } else {
                    codeList.add(sb.toString());
                    codeList.add(String.valueOf(input[i]));
                    sb.setLength(0);
                }
            }
            // 단어의 첫 문자가 0인 경우를 제외하기 위해 단어의 첫 문자를 저장
            firstCharacter = new ArrayList<>();
            for (String code : codeList) {
                char first = code.charAt(0);
                if (first > 64 && !firstCharacter.contains(first)) firstCharacter.add(first);
            }

            insertNumber(alphabetSet, 0);
        }
        System.out.println(answer);
    }

    // 0~9 까지의 숫자를 각 알파벳에 하나씩 집어넣는 로직 (순열)
    public static void insertNumber(ArrayList<Character> alphabetSet, int depth) {
        if (depth == alphabetSet.size()) {
            answer += calculate();
            return;
        }

        for (int i = 0; i < 10; i++) {
            if (!visit[i] && !map.containsKey(alphabetSet.get(depth))) {
                // 첫 문자가 0인 경우엔 더이상 진행하지 않습니다.
                if (i == 0 && firstCharacter.contains(alphabetSet.get(depth))) continue;

                map.put(alphabetSet.get(depth), i);
                visit[i] = true;
                insertNumber(alphabetSet, depth+1);
                map.remove(alphabetSet.get(depth));
                visit[i] = false;
            }
        }
    }

    /**
     * 좌변과 우변을 계산하여 일치 여부 판별
     * @return 일치하면 좌변값, 불일치하면 0
     */
    public static int calculate() {
        Queue<Integer> numberQ = new LinkedList<>();
        Queue<Character> operatorQ = new LinkedList<>();
        int leftSide = 0;
        int rightSide = 0;

        for (String code : codeList) {
            char current = code.charAt(0);
            // '=' 인 경우, 현재 큐에 담긴 값들을 계산하여 좌변에 할당
            if (current == '=') {
                leftSide = numberQ.poll();
                while (!numberQ.isEmpty() && !operatorQ.isEmpty()) {
                    leftSide = operating(leftSide, numberQ.poll(), operatorQ.poll());
                }
            // 문자열인 경우, 문자열을 숫자로 치환하여 큐에 push
            } else if (current > 48) {
                numberQ.offer(stringToNumber(code));
            // 연산자인 경우, 연산자 큐에 push
            } else {
                operatorQ.offer(current);
            }
        }

        /**
         * 위 루프 종료 후에는 numberQ에 우변만 남아있으므로 우변값 계산하여 rightSide에 할당
         */
        rightSide = numberQ.poll();
        while (!numberQ.isEmpty()) {
            rightSide = operating(rightSide, numberQ.poll(), operatorQ.poll());
        }

        if (leftSide == rightSide) return leftSide;
        else return 0;
    }

    public static int stringToNumber(String code) {
        String tmp = "";
        for (int i = 0; i < code.length(); i++) {
            char current = code.charAt(i);
            tmp += String.valueOf(map.get(current));
        }
        return Integer.parseInt(tmp);
    }

    public static int operating(int base, int calculate, char operator) {
        switch (operator) {
            case '+':
                base += calculate;
                break;
            case '-':
                base -= calculate;
                break;
            case '*':
                base *= calculate;
                break;
            case '/':
                base /= calculate;
                break;
        }
        return base;
    }
}
```