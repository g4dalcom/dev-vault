# [문제링크](https://school.programmers.co.kr/learn/courses/30/lessons/12936)

## 📝 문제

n명의 사람이 일렬로 줄을 서고 있습니다. n명의 사람들에게는 각각 1번부터 n번까지 번호가 매겨져 있습니다. n명이 사람을 줄을 서는 방법은 여러가지 방법이 있습니다. 예를 들어서 3명의 사람이 있다면 다음과 같이 6개의 방법이 있습니다.

- [1, 2, 3]
- [1, 3, 2]
- [2, 1, 3]
- [2, 3, 1]
- [3, 1, 2]
- [3, 2, 1]

사람의 수 n과, 자연수 k가 주어질 때, 사람을 나열 하는 방법을 사전 순으로 나열 했을 때, k번째 방법을 return하는 solution 함수를 완성해주세요.

###### 제한사항

- n은 20이하의 자연수 입니다.
- k는 n! 이하의 자연수 입니다.

---

##### 입출력 예

|n|k|result|
|---|---|---|
|3|5|[3,1,2]|

---

### 💡 풀이

순열을 이용해서 모든 경우의 수를 구한 뒤에 k번 째를 가져오는 식으로 풀면 효율성 테스트를 모두 통과하지 못한다. 

그래서 boolean flag 를 이용해서 k번 째까지만 탐색고 dfs를 종료하도록 짜보기도 했는데 이것 역시 효율성 테스트를 통과하지 못했다.

그래서 특정한 위치의 값을 바로 찾을 수 있는 방법을 찾아보기 위해 규칙이 있는지 알아보았다.

\[1, 2, 3\] 이라는 배열이 존재할 때 이 배열에서 나올 수 있는 경우의 수는 6개이다.
\[1, 2, 3\], \[1, 3, 2\], \[2, 1, 3\], \[2, 3, 1\], \[3, 1, 2\], \[3, 2, 1\]

\[1, 2, 3, 4\] 인 경우의 경우의 수는
\[1, 2, 3, 4\], \[1, 2, 4, 3\], \[1, 3, 2, 4\], \[1, 3, 4, 2\], \[1, 4, 2, 3\], \[1, 4, 3, 2\] * 4개로 24개이다.

이 때 규칙을 보면, n-1의 경우의 수가 n의 맨 앞자리 사이클이 된다는 것이다.

\[1, 2, 3, 4\] 의 경우 맨 앞자리가 1인 경우의 수는 6개이며 7번째부터 \[2, 1, 3, 4\] 처럼 앞자리가 2로 바뀐다.

\[1, 2, 3\] 의 경우는 2만큼의 사이클을 갖고 있으며 이것은 배열 \[1, 2\] 의 경우의 수이기도 하다.

단순히 규칙만 보면 이러한데 수학적으로 접근하면 팩토리얼과 관련이 있다.
\[1, 2, 3\] 의 경우는 3! = 6, \[1, 2, 3, 4\] = 4! = 24인 것이다.
팩토리얼로 구한 수를 n으로 나누면 n의 사이클을 알 수 있게 된다.

\[1, 2, 3, 4\] = 4! = 24
24 / n(4) = 6

즉 6의 사이클을 갖고 7번째부터 다른 사이클로 바뀐다는 것이다!

그러면 k가 주어졌을 때, **k / 사이클** 을 하면 앞자리를 구할 수 있고 구한 자릿수를 제외하고 나머지 수들로 위 연산을 반복하면 k번 째 배열을 구할 수 있다.

그리고 신경써야 하는 점이 있는데
n = 4, \[1, 2, 3, 4\] 일 때 사이클은 6이 되는데
k = 1, k = 2, k = 3 ... 인 경우는 **k / 사이클** 이 0이 되므로 앞자리는 1이 정상적으로 계산이 되지만 k = 6이 되면 **k / 사이클** 은 1이 되어서 앞자리가 2로 바뀌게 된다.
사이클이 6일 때 k = 6인 경우에도 앞자리는 바뀌지 않아야 한다. 
따라서 인덱스를 계산할 때 k 대신 k-1로 계산을 해주어야 한다는 것이다!


### 🔍 정답

```java
import java.util.*;

class Solution {
    public int[] solution(int n, long k) {
        ArrayList<Integer> people = new ArrayList<>();
        int[] result = new int[n];

        long factorial = 1;
        for (int i = 1; i <= n; i++) {
            factorial *= i;
            people.add(i);
        }

        k--;
        int index = 0;
        while (n > 0) {
            factorial /= n;
            int digit = (int) (k / factorial);
            result[index++] = people.get(digit);
            people.remove(digit);
            
            k %= factorial;
            n--;
        }
        
        return result;
    }
}
```