# [문제링크](https://school.programmers.co.kr/learn/courses/30/lessons/12980)

## 📝 문제

OO 연구소는 한 번에 K 칸을 앞으로 점프하거나, (현재까지 온 거리) x 2 에 해당하는 위치로 순간이동을 할 수 있는 특수한 기능을 가진 아이언 슈트를 개발하여 판매하고 있습니다. 이 아이언 슈트는 건전지로 작동되는데, 순간이동을 하면 건전지 사용량이 줄지 않지만, 앞으로 K 칸을 점프하면 K 만큼의 건전지 사용량이 듭니다. 그러므로 아이언 슈트를 착용하고 이동할 때는 순간 이동을 하는 것이 더 효율적입니다. 아이언 슈트 구매자는 아이언 슈트를 착용하고 거리가 N 만큼 떨어져 있는 장소로 가려고 합니다. 단, 건전지 사용량을 줄이기 위해 점프로 이동하는 것은 최소로 하려고 합니다. 아이언 슈트 구매자가 이동하려는 거리 N이 주어졌을 때, 사용해야 하는 건전지 사용량의 최솟값을 return하는 solution 함수를 만들어 주세요.

예를 들어 거리가 5만큼 떨어져 있는 장소로 가려고 합니다.  
아이언 슈트를 입고 거리가 5만큼 떨어져 있는 장소로 갈 수 있는 경우의 수는 여러 가지입니다.

- 처음 위치 0 에서 5 칸을 앞으로 점프하면 바로 도착하지만, 건전지 사용량이 5 만큼 듭니다.
- 처음 위치 0 에서 2 칸을 앞으로 점프한 다음 순간이동 하면 (현재까지 온 거리 : 2) x 2에 해당하는 위치로 이동할 수 있으므로 위치 4로 이동합니다. 이때 1 칸을 앞으로 점프하면 도착하므로 건전지 사용량이 3 만큼 듭니다.
- 처음 위치 0 에서 1 칸을 앞으로 점프한 다음 순간이동 하면 (현재까지 온 거리 : 1) x 2에 해당하는 위치로 이동할 수 있으므로 위치 2로 이동됩니다. 이때 다시 순간이동 하면 (현재까지 온 거리 : 2) x 2 만큼 이동할 수 있으므로 위치 4로 이동합니다. 이때 1 칸을 앞으로 점프하면 도착하므로 건전지 사용량이 2 만큼 듭니다.

위의 3가지 경우 거리가 5만큼 떨어져 있는 장소로 가기 위해서 3번째 경우가 건전지 사용량이 가장 적으므로 답은 2가 됩니다.

##### 제한 사항

- 숫자 N: 1 이상 10억 이하의 자연수
- 숫자 K: 1 이상의 자연수

##### 입출력 예

|N|result|
|---|---|
|5|2|
|6|2|
|5000|5|

##### 입출력 예 설명

입출력 예 #1  
위의 예시와 같습니다.

입출력 예 #2  
처음 위치 0 에서 1 칸을 앞으로 점프한 다음 순간이동 하면 (현재까지 온 거리 : 1) x 2에 해당하는 위치로 이동할 수 있으므로 위치 2로 이동합니다. 이때 1 칸을 앞으로 점프하면 위치3으로 이동합니다. 이때 다시 순간이동 하면 (현재까지 온 거리 : 3) x 2 이동할 수 있으므로 위치 6에 도착합니다. 이 경우가 건전지 사용량이 가장 적으므로 2를 반환해주면 됩니다.

---

### 💡 풀이

- 처음엔 dp로 접근을 했다.
- i = 1 부터 n 까지 늘려가면서 아래의 경우를 비교하였다.
	- 한 칸 점프했을 때 dp\[i\] = dp\[i-1\] +1
	- 순간이동을 했을 때 dp\[i\*2\] = dp\[i\]

### ❌ 메모리, 시간 초과

```java
import java.util.*;

public class Solution {
    public int solution(int n) {
        int[] dp = new int[n+1];
        Arrays.fill(dp, n);
        dp[0] = 0;
        
        for (int i = 1; i < n+1; i++) {
            dp[i] = Math.min(dp[i], dp[i-1] + 1);
            
            if (i * 2 <= n) {
                dp[i*2] = dp[i];
            }
            
            if (i * 2 == n) return dp[n];   
        }
        
        return dp[n];
    }
}
```

- 메모리 초과, 시간 초과가 나서 규칙을 찾아보다가 현재 위치에서 두 배인 수는 현재 위치와 같은 값을 가지므로 입력받은 n값을 2로 나누어떨어지지 않을 때까지 나눈 후 그 값만 구한다면 훨씬 적은 탐색을 할 수 있다고 생각했다.
- 그리고 i \*2 를 한 인덱스뿐만 아니라 n보다 크지 않다면 계속 누적으로 \*2를 해서 최대한 앞의 탐색에서 n을 구하고자 하였는데 이 또한 메모리, 시간 초과가 났다 ㅠㅠ

### ❌ 메모리, 시간 초과

```java
import java.util.*;

public class Solution {
    public int solution(int n) {        
        while (n % 2 == 0) {
            n /= 2;
        }
        
        int[] dp = new int[n+1];
        Arrays.fill(dp, n);
        dp[0] = 0;
        
        for (int i = 1; i < n+1; i++) {
            dp[i] = Math.min(dp[i], dp[i-1] + 1);
        
            int temp = i;
            while (true) {
                temp *= 2;
                if (temp > n) break;
                
                dp[temp] = dp[i];
                
                if (temp == n) return dp[i];
            }
        }
        
        return dp[n];
    }
}
```


- n = 6인 경우는 3에서 점프했을 때와 같고 3은 2에서 +1을 한 것과 같다.
- n = 5인 경우는 바로 순간이동해서 이동할 수 없기 때문에 무조건 4에서 +1을 해주어야 하고 4는 2에서 점프한 것이다.
- 이러한 규칙에 착안해서 n을 계속 2로 나누어주다가 홀수가 나오면(3은 2에서 +1은 한 값이듯이) n--를 하고 카운팅을 해주었다.

### 🔍 정답

```java
import java.util.*;

public class Solution {
    public int solution(int n) {        
        int count = 0;
        while (n > 0) {
            if (n % 2 == 1) {
                n--;
                count++;
            }         
            n /= 2;
        }       
        return count;
    }
}
```


- 진법에 대한 계산이 약해서 전혀 떠올리지 못했지만 2배수라는 문제의 특성을 이용해서 2진법으로 해결한 사람도 있었다. n을 2진수로 바꾸었을 때 1의 개수가 곧 정답이 되는 것인데
- \*2 를 보고 비트 연산 -> 이진법을 떠올린 사람도 있었고
- 1, 2, 4, 8, 16은 같은 수를 가지는데 이는 이진법으로 1, 10, 100, 1000, 10000 이기 때문에 여기서 눈치챈 사람도 있었다.
- 진법 문제도 심심치않게 나오는데 익숙해진다면 이런 문제를 좀 더 쉽게 해결할 수 있을 것 같다!

### 💡 정답(2진법)

```java
import java.util.*;

public class Solution {
    public int solution(int n) {
        return Integer.bitCount(n);
    }
}
```